--------------------------------------------------------------------------------
-- BE Robot Lego Mindstorms EV3
-- Firstname and Name: Ronan Keane & Joseph Mased
-- ISAE MAE-ES â€“ 2022-2023
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- Constant values
--------------------------------------------------------------------------------
-- Declare constants if needed:
-- example: 
-- const DARK int;


--------------------------------------------------------------------------------
-- Main node
--------------------------------------------------------------------------------
-- Inputs:
--   sensors 1 to 4 (from ports IN1 to IN4)
--   speed of motors A to B (from ports OUTA to OUTD)
-- Assumption:
--   sensor_1 = right touch sensor
--   sensor_4 = left touch sensor
--   sensor_2 = color sensor
--   sensor_3 = utrasonic sensor
--   motor_speed_sensor_a = speed of motor A (right wheel)
--   motor_speed_sensor_b = speed of motor B (left wheel)
--   motor_speed_sensor_c = speed of motor C (engine to turn the ultrasonic sensor right and left)
--   no motor on output port D
--------------------------------------------------------------------------------
node main_robot (
		sensor_1 : bool ;
		sensor_2 : int ;
		sensor_3 : int ;
		sensor_4 : bool ;
		motor_speed_sensor_a : int ;
		motor_speed_sensor_b : int ;
		motor_speed_sensor_c : int ;
		motor_speed_sensor_d : int ;
		)
--------------------------------------------------------------------------------
-- Outputs:
--   Required rotation direction for each motor (clockwise versus counterclockwise)
--   Required command mode for each motor (speed versus position)
--   Required value of the command for each motor
-- Assumption
--   Motor_A = right wheel
--   Motor_B = left wheel
--   Motor_C = engine to turn the ultrasonic sensor right and left
--   no motor on output port D
--------------------------------------------------------------------------------
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	Clockwise_C : bool; Counterclockwise_C : bool; Cmd_Position_C : bool ; Cmd_Speed_C : bool; Value_C : int; 
	Clockwise_D : bool; Counterclockwise_D : bool; Cmd_Position_D : bool ; Cmd_Speed_D : bool; Value_D : int; 
	);
--------------------------------------------------------------------------------

var _, reset, force_stop: bool;
var state, count: int;
var T_FW_S, T_BW_S, T_R_S, T_L_S, T_S_FW, T_S_BW, T_S_R, T_S_L: bool;

let

--counter  = 0 -> if (pre(counter) > 99) then 0
--		else pre(counter) + 1;

--(Clockwise_A, Counterclockwise_A, Cmd_Position_A, Cmd_Speed_A, Value_A,
--Clockwise_B, Counterclockwise_B, Cmd_Position_B, Cmd_Speed_B, 
--Value_B) = Stop(_) -> if (counter < 69) then Forward(_)
--			else if (counter >=69 and counter < 79) then Backward(_)
--			else if (counter >=79 and counter <=100)
--			else Stop(_);				


---------------------------------------
-- M1:
-- Normal behavior: FW -> BW -> Right -> FW
-- T_S_FW 10 -> T_FW_S 60 -> T_S_BW 65 -> T_BW_S 85 -> T_S_R 90 -> T_R_S 95
-- transitions from Stop state are not allowed if motor A and B's sensors are not 0
-- M2:
-- if the value of sensor_2 is between 5 and 10, all the transitions to 0 become true, 
-- thus forcing the Stop state to become true no matter what the previous state was

_ = false;

reset = false -> if pre(count) = 15 then true --99
		else false;
count = Counter(reset);

force_stop = (sensor_2 >= 5 and sensor_2 <= 10);

T_S_FW = false -> if ((pre count = 2) and 
	(motor_speed_sensor_a = 0 and motor_speed_sensor_b = 0) and 
	(not force_stop)) 
		then true
	else false;
	
T_FW_S = false -> if ((pre count = 4) or
	(force_stop))
		then true
	else false;
	
T_S_BW = false -> if ((pre count = 6) and 
	(motor_speed_sensor_a = 0 and motor_speed_sensor_b = 0) and 
	(not force_stop)) 
		then true
	else false;
	
T_BW_S = false -> if ((pre count = 8) or
	(force_stop))
		then true
	else false;
	
T_S_R = false -> if ((pre count = 12)  and 
	(motor_speed_sensor_a = 0 and motor_speed_sensor_b = 0) and 
	(not force_stop)) 
		then true
	else false;
	
T_R_S = false -> if ((pre count = 14) or
	(force_stop)) 
		then true
	else false;

T_L_S = false -> if (force_stop) then true
	else false;
T_S_L = false;


state = Automata_1(T_FW_S, T_BW_S, T_R_S, T_L_S, T_S_FW, T_S_BW, T_S_R, T_S_L);

(Clockwise_A, Counterclockwise_A, Cmd_Position_A, Cmd_Speed_A, Value_A,
Clockwise_B, Counterclockwise_B, Cmd_Position_B, Cmd_Speed_B, 
Value_B) = if state = 0 then Stop(_)
		else if state = 1 then Forward(_)
		else if state = 2 then Backward(_)
		else if state = 3 then Right(_)	
		else if state = 4 then Left(_)
		else Stop(_);
		
--%MAIN;


tel	
--------------------------------------------------------------------------------
	


--------------------------------------------------------------------------------
-- Place other nodes below if needed
node Automata_1(T_FW_S, T_BW_S, T_R_S, T_L_S, T_S_FW, T_S_BW, T_S_R, T_S_L : bool)
returns(state: int);

var init, init_stop: bool;
var S_FW, S_BW, S_R, S_L, S_S: bool;

let
init = false;
init_stop = true;

S_FW = init -> if (pre(S_FW) and T_FW_S) then false
		else if (pre(S_S) and T_S_FW) then true
		else pre(S_FW);
		
S_BW = init -> if (pre(S_BW) and T_BW_S) then false
		else if (pre(S_S) and T_S_BW) then true
		else pre(S_BW);

S_L = init -> if (pre(S_L) and T_L_S) then false
		else if pre(S_S) and T_S_L then true
		else pre(S_L);

S_R = init -> if (pre(S_R) and T_R_S) then false
		else if pre(S_S) and T_S_R then true
		else pre(S_R);
		
		
S_S = init_stop -> if (pre(S_S) and (T_S_FW or T_S_BW or T_S_R or T_S_L)) then false	
		else if ((pre(S_FW) and T_FW_S)
			or (pre(S_BW) and T_BW_S)
			or (pre(S_L) and T_L_S)
			or (pre(S_R) and T_R_S))
			then true
		else pre(S_S);		

state = 0 -> if S_S then 0
	else if S_FW then 1
	else if S_BW then 2
	else if S_R then 3
	else if S_L then 4
	else pre(state);
tel

node Forward(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = true ;
Counterclockwise_A = false;
Value_A = 80;

--Left Wheel
Clockwise_B = true;
Counterclockwise_B = false;
Value_B = 80;
tel;


node Backward(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int;
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false ;
Counterclockwise_A = true;
Value_A = 40;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = true;
Value_B = 40;
tel;


node Left(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = true ;
Counterclockwise_A = false;
Value_A = 30;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = true;
Value_B = 30;
tel;


node Right(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false ;
Counterclockwise_A = true;
Value_A = 30;

--Left Wheel
Clockwise_B = true;
Counterclockwise_B = false;
Value_B = 30;
tel;


node Stop(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false;
Counterclockwise_A = false;
Value_A = 0;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = false;
Value_B = 0;
tel;


node Counter(reset: bool) returns(count: int);
let
count = 0 -> if reset then 0 else pre(count) + 1;
tel

---------------------

node RisingE(x: bool) returns (y: bool);
let
y = x -> x and (not pre x);
tel

node Switch( Set, Reset, Init : bool ) returns ( x : bool );
let
x = 	if Set then true
	else if Reset then false
	else (Init -> pre x);
tel
