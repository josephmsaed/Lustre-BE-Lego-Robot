--------------------------------------------------------------------------------
-- BE Robot Lego Mindstorms EV3
-- Firstname and Name: Ronan Keane & Joseph Mased
-- ISAE MAE-ES â€“ 2022-2023
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- Constant values
--------------------------------------------------------------------------------
-- Declare constants if needed:
-- example: 
-- const DARK int;


--------------------------------------------------------------------------------
-- Main node
--------------------------------------------------------------------------------
-- Inputs:
--   sensors 1 to 4 (from ports IN1 to IN4)
--   speed of motors A to B (from ports OUTA to OUTD)
-- Assumption:
--   sensor_1 = right touch sensor
--   sensor_4 = left touch sensor
--   sensor_2 = color sensor
--   sensor_3 = utrasonic sensor
--   motor_speed_sensor_a = speed of motor A (right wheel)
--   motor_speed_sensor_b = speed of motor B (left wheel)
--   motor_speed_sensor_c = speed of motor C (engine to turn the ultrasonic sensor right and left)
--   no motor on output port D
--------------------------------------------------------------------------------
node main_robot (
		sensor_1 : bool ;
		sensor_2 : int ;
		sensor_3 : int ;
		sensor_4 : bool ;
		motor_speed_sensor_a : int ;
		motor_speed_sensor_b : int ;
		motor_speed_sensor_c : int ;
		motor_speed_sensor_d : int ;
		)
--------------------------------------------------------------------------------
-- Outputs:
--   Required rotation direction for each motor (clockwise versus counterclockwise)
--   Required command mode for each motor (speed versus position)
--   Required value of the command for each motor
-- Assumption
--   Motor_A = right wheel
--   Motor_B = left wheel
--   Motor_C = engine to turn the ultrasonic sensor right and left
--   no motor on output port D
--------------------------------------------------------------------------------
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	Clockwise_C : bool; Counterclockwise_C : bool; Cmd_Position_C : bool ; Cmd_Speed_C : bool; Value_C : int; 
	Clockwise_D : bool; Counterclockwise_D : bool; Cmd_Position_D : bool ; Cmd_Speed_D : bool; Value_D : int; 
	);
--------------------------------------------------------------------------------
var _: bool;
 reset_switch: bool;
 state: int;
 ESTOP: bool;

let
---------------------------------------

Clockwise_C = false; Counterclockwise_C = false; Cmd_Position_C = false; Cmd_Speed_C = false; Value_C = 0; 
Clockwise_D = false; Counterclockwise_D = false; Cmd_Position_D = false ; Cmd_Speed_D = false; Value_D =0; 

_ = false;

--sensor_status = SwitchPrototype(reset_switch, sensor_1, sensor_4);
--sensor_1_persis = Switch(sensor_1, reset_switch);
ESTOP = false -> if sensor_1 or sensor_4 then true
					else pre ESTOP;

state = Automata_0( sensor_1, sensor_4, sensor_3,sensor_2);

(Clockwise_A, Counterclockwise_A, Cmd_Position_A, Cmd_Speed_A, Value_A,
Clockwise_B, Counterclockwise_B, Cmd_Position_B, Cmd_Speed_B, 
Value_B) = if state = 0 then Stop(_)
		else if state = 1 then Forward(_)
		else if state = 2 then Backward(_)
		else if state = 3 then Right(_)	
		else if state = 4 then Left(_)
		else Stop(_);
	tel	
--------------------------------------------------------------------------------
	


--------------------------------------------------------------------------------
-- Place other nodes below if needed

node Automata_0(sensor_1, sensor_4: bool; sensor_3,sensor_2: int)
returns(state: int);

var init, init_stop: bool;
 count: int;
 count_bumper: int;
 count_idle: int;
 reset: bool;
 idle: bool;
 right_bumper_hit: bool;
 left_bumper_hit: bool;
 obstacle: bool;
 force_stop: bool;
 S_FW, S_BW, S_R, S_L, S_S: bool;
let
force_stop =  (sensor_2 >= 0 and sensor_2 <= 10) or (sensor_3 <= 200);
init = false;
init_stop = true;

reset = false -> if (pre count = 305) then true
		else false;

reset_idle = false -> if (pre count_idle = 355) then true
		else false;

right_bumper_hit = false -> Switch(sensor_1, reset);  
left_bumper_hit = false -> Switch(sensor_4, reset);    
obstacle_detected = false -> Switch(sensor_3 <= 200 , reset_ultra);  

idle = not (right_bumper_hit or left_bumper_hit or obstacle_detected);

count_idle = 0-> if (idle) then Counter(reset_idle) 
			else if force_stop then pre count_idle
			else 0;

count_ultra = 0-> if (obstacle_detected) then Counter(reset_ultra) 
			else 0;

Value_C = 0 -> if obstacle_detected then 10 else 0;

Clockwise_C = 0 -> if obstacle_detected and count_ultra > 5 and count_ultra < 45 then true else false;

count_bumper = 0-> if (right_bumper_hit or left_bumper_hit) then Counter(reset) 
			else if force_stop then pre count_bumper
			else 0;

S_FW = init -> if  (idle) and (count_idle > 5 and count_idle < 200) then true
				else false;

S_BW = init -> if ((idle) and (count_idle > 205 and count_idle < 250)) or (((right_bumper_hit or left_bumper_hit) and count_bumper > 5 and count_bumper < 200) and not force_stop) then true
				else false;

S_L = init -> if ((idle) and (count_idle > 255 and count_idle < 350)) or (right_bumper_hit and count_bumper > 205 and count_bumper < 300) and not force_stop then true
				else false;

S_R = init -> if (left_bumper_hit and count_bumper > 205 and count_bumper < 300) and not force_stop then true
				else false;
		
S_S = init_stop ->if (right_bumper_hit or left_bumper_hit) and count_bumper < 5  then true
				 else if not (S_R or S_FW or S_BW or S_L) or force_stop then true
				 else false;

state = 0 -> if S_S then 0 -- stop
	else if S_FW then 1 
	else if S_BW then 2
	else if S_R then 3
	else if S_L then 4
    else pre(state);
tel

-- Moving Forward State Node
node Forward(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = true ;
Counterclockwise_A = false;
Value_A = 80;

--Left Wheel
Clockwise_B = true;
Counterclockwise_B = false;
Value_B = 80;
tel;

-- Reversing State Node
node Backward(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int;
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false ;
Counterclockwise_A = true;
Value_A = 40;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = true;
Value_B = 40;
tel;

-- Turning Left State Node
node Left(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = true ;
Counterclockwise_A = false;
Value_A = 30;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = true;
Value_B = 30;
tel;

-- Turning Right State Node
node Right(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);

let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false ;
Counterclockwise_A = true;
Value_A = 30;

--Left Wheel
Clockwise_B = true;
Counterclockwise_B = false;
Value_B = 30;
tel;

-- Stop State Node
node Stop(_: bool)
returns (
	Clockwise_A : bool; Counterclockwise_A : bool; Cmd_Position_A : bool ; Cmd_Speed_A : bool; Value_A : int; 
	Clockwise_B : bool; Counterclockwise_B : bool; Cmd_Position_B : bool ; Cmd_Speed_B : bool; Value_B : int; 
	);
let
Cmd_Position_A = false;
Cmd_Speed_A = true;
Cmd_Position_B = false;
Cmd_Speed_B = true;

--Right Wheel
Clockwise_A = false;
Counterclockwise_A = false;
Value_A = 0;

--Left Wheel
Clockwise_B = false;
Counterclockwise_B = false;
Value_B = 0;
tel;

--Counter used to time the transitions between states
node Counter(reset: bool) returns(count: int);
let
count = 0 -> if reset then 0 else pre(count) + 1;
tel

--Switch is used to notify that the either the left or right bumpers have been hit 
--or that an obstacle has been detected by the sensors.
--The switch is reset at the end of the operation's cycle that reacts to each of the disturbances
node Switch(Set, Reset: bool) returns (S: bool);
let
S = false -> if (pre S) then not reset else Set;
tel

